/*
 *  Copyright 2016 Google Inc. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.google.android.apps.forscience.whistlepunk.audiogen.voices;

/**************
** WARNING - this code automatically generated by Syntona.
** The real source is probably a Syntona patch.
** Do NOT edit this file unless you copy it to another directory and change the name.
** Otherwise it is likely to get clobbered the next time you
** export Java source code from Syntona.
**
** Syntona is available from: http://www.softsynth.com/syntona/
*/

import com.jsyn.ports.UnitOutputPort;
import com.jsyn.unitgen.UnitVoice;
import com.jsyn.ports.UnitInputPort;
import com.jsyn.unitgen.SineOscillator;
import com.softsynth.shared.time.TimeStamp;
import com.jsyn.unitgen.PassThrough;
import com.jsyn.unitgen.EnvelopeDAHDSR;
import com.jsyn.unitgen.Circuit;

public class SineEnvelope extends SimpleJsynUnitVoiceBase {
    // Declare units and ports.
    PassThrough mFrequencyPassThrough;
    public UnitInputPort frequency;
    PassThrough mAmplitudePassThrough;
    public UnitInputPort amplitude;
    PassThrough mOutputPassThrough;
    public UnitOutputPort output;
    SineOscillator mSineOsc;
    EnvelopeDAHDSR mDAHDSR;

    // Declare inner classes for any child circuits.

    public SineEnvelope() {
        // Create unit generators.
        add(mFrequencyPassThrough = new PassThrough());
        addPort(frequency = mFrequencyPassThrough.input, "frequency");
        add(mAmplitudePassThrough = new PassThrough());
        addPort(amplitude = mAmplitudePassThrough.input, "amplitude");
        add(mOutputPassThrough = new PassThrough());
        addPort( output = mOutputPassThrough.output, "output");
        add(mSineOsc = new SineOscillator());
        add(mDAHDSR = new EnvelopeDAHDSR());
        // Connect units and ports.
        mFrequencyPassThrough.output.connect(mSineOsc.frequency);
        mAmplitudePassThrough.output.connect(mSineOsc.amplitude);
        mSineOsc.output.connect(mDAHDSR.amplitude);
        mDAHDSR.output.connect(mOutputPassThrough.input);
        // Setup
        frequency.setup(40.0, 698.4584691287101, 8000.0);
        amplitude.setup(0.0, 0.999969482421875, 1.0);
        mDAHDSR.input.set(0.0);
        // Sum of these times should not exceed MIN_TIME_VALUE_CHANGE_MS
        mDAHDSR.delay.set(0.01);
        mDAHDSR.attack.set(0.01);
        mDAHDSR.hold.set(0.04);
        mDAHDSR.decay.set(0.01);
        mDAHDSR.sustain.set(0.045);
        mDAHDSR.release.set(0.01);
    }

    public EnvelopeDAHDSR getDAHDSR() {
        return mDAHDSR;
    }

    public void noteOn(double frequency, double amplitude, TimeStamp timeStamp) {
        this.frequency.set(frequency, timeStamp);
        this.amplitude.set(amplitude, timeStamp);
        mDAHDSR.input.on(timeStamp);
    }

    public void noteOff(TimeStamp timeStamp) {
        mDAHDSR.input.off(timeStamp);
    }
    
    public UnitOutputPort getOutput() {
        return output;
    }
}
